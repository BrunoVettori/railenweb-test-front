{"version":3,"file":"compilers.js","sources":["../../src/compilers.ts"],"sourcesContent":["import * as t from '@babel/types'\nimport babel from '@babel/core'\nimport generate from '@babel/generator'\nimport * as template from '@babel/template'\nimport { splitPrefix } from './constants'\nimport { eliminateUnreferencedIdentifiers } from './eliminateUnreferencedIdentifiers'\nimport type { CompileAstFn } from './ast'\n\ntype SplitModulesById = Record<\n  string,\n  { id: string; node: t.FunctionExpression }\n>\n\ninterface State {\n  filename: string\n  opts: {\n    minify: boolean\n    root: string\n  }\n  imported: Record<string, boolean>\n  refs: Set<any>\n  serverIndex: number\n  splitIndex: number\n  splitModulesById: SplitModulesById\n}\n\nexport async function compileFile(opts: {\n  code: string\n  compileAst: CompileAstFn\n  filename: string\n}) {\n  return await opts.compileAst({\n    code: opts.code,\n    filename: opts.filename,\n    getBabelConfig: () => ({\n      plugins: [\n        [\n          {\n            visitor: {\n              Program: {\n                enter(programPath: babel.NodePath<t.Program>, state: State) {\n                  const splitUrl = `${splitPrefix}:${opts.filename}?${splitPrefix}`\n\n                  /**\n                   * If the component for the route is being imported from\n                   * another file, this is to track the path to that file\n                   * the path itself doesn't matter, we just need to keep\n                   * track of it so that we can remove it from the imports\n                   * list if it's not being used like:\n                   *\n                   * `import '../shared/imported'`\n                   */\n                  let existingCompImportPath: string | null = null\n                  let existingLoaderImportPath: string | null = null\n\n                  programPath.traverse(\n                    {\n                      CallExpression: (path) => {\n                        if (!t.isIdentifier(path.node.callee)) {\n                          return\n                        }\n\n                        if (\n                          !(\n                            path.node.callee.name === 'createRoute' ||\n                            path.node.callee.name === 'createFileRoute'\n                          )\n                        ) {\n                          return\n                        }\n\n                        if (t.isCallExpression(path.parentPath.node)) {\n                          const options = resolveIdentifier(\n                            path,\n                            path.parentPath.node.arguments[0],\n                          )\n\n                          let found = false\n\n                          const hasImportedOrDefinedIdentifier = (\n                            name: string,\n                          ) => {\n                            return programPath.scope.hasBinding(name)\n                          }\n\n                          if (t.isObjectExpression(options)) {\n                            options.properties.forEach((prop) => {\n                              if (t.isObjectProperty(prop)) {\n                                if (t.isIdentifier(prop.key)) {\n                                  if (prop.key.name === 'component') {\n                                    const value = prop.value\n\n                                    if (t.isIdentifier(value)) {\n                                      existingCompImportPath =\n                                        getImportSpecifierAndPathFromLocalName(\n                                          programPath,\n                                          value.name,\n                                        ).path\n\n                                      removeIdentifierLiteral(path, value)\n                                    }\n\n                                    // Prepend the import statement to the program along with the importer function\n                                    // Check to see if lazyRouteComponent is already imported before attempting\n                                    // to import it again\n\n                                    if (\n                                      !hasImportedOrDefinedIdentifier(\n                                        'lazyRouteComponent',\n                                      )\n                                    ) {\n                                      programPath.unshiftContainer('body', [\n                                        template.statement(\n                                          `import { lazyRouteComponent } from '@tanstack/react-router'`,\n                                        )(),\n                                      ])\n                                    }\n\n                                    if (\n                                      !hasImportedOrDefinedIdentifier(\n                                        '$$splitComponentImporter',\n                                      )\n                                    ) {\n                                      programPath.unshiftContainer('body', [\n                                        template.statement(\n                                          `const $$splitComponentImporter = () => import('${splitUrl}')`,\n                                        )(),\n                                      ])\n                                    }\n\n                                    prop.value = template.expression(\n                                      `lazyRouteComponent($$splitComponentImporter, 'component')`,\n                                    )()\n\n                                    programPath.pushContainer('body', [\n                                      template.statement(\n                                        `function DummyComponent() { return null }`,\n                                      )(),\n                                    ])\n\n                                    found = true\n                                  } else if (prop.key.name === 'loader') {\n                                    const value = prop.value\n\n                                    if (t.isIdentifier(value)) {\n                                      existingLoaderImportPath =\n                                        getImportSpecifierAndPathFromLocalName(\n                                          programPath,\n                                          value.name,\n                                        ).path\n\n                                      removeIdentifierLiteral(path, value)\n                                    }\n\n                                    // Prepend the import statement to the program along with the importer function\n\n                                    if (\n                                      !hasImportedOrDefinedIdentifier('lazyFn')\n                                    ) {\n                                      programPath.unshiftContainer('body', [\n                                        template.smart(\n                                          `import { lazyFn } from '@tanstack/react-router'`,\n                                        )() as t.Statement,\n                                      ])\n                                    }\n\n                                    if (\n                                      !hasImportedOrDefinedIdentifier(\n                                        '$$splitLoaderImporter',\n                                      )\n                                    ) {\n                                      programPath.unshiftContainer('body', [\n                                        template.statement(\n                                          `const $$splitLoaderImporter = () => import('${splitUrl}')`,\n                                        )(),\n                                      ])\n                                    }\n\n                                    prop.value = template.expression(\n                                      `lazyFn($$splitLoaderImporter, 'loader')`,\n                                    )()\n\n                                    found = true\n                                  }\n                                }\n                              }\n\n                              programPath.scope.crawl()\n                            })\n                          }\n\n                          if (found as boolean) {\n                            programPath.pushContainer('body', [\n                              template.statement(\n                                `function TSR_Dummy_Component() {}`,\n                              )(),\n                            ])\n                          }\n                        }\n                      },\n                    },\n                    state,\n                  )\n\n                  eliminateUnreferencedIdentifiers(programPath)\n\n                  /**\n                   * If the component for the route is being imported,\n                   * and it's not being used, remove the import statement\n                   * from the program, by checking that the import has no\n                   * specifiers\n                   */\n                  if (\n                    (existingCompImportPath as string | null) ||\n                    (existingLoaderImportPath as string | null)\n                  ) {\n                    programPath.traverse({\n                      ImportDeclaration(path) {\n                        if (path.node.specifiers.length > 0) return\n                        if (\n                          path.node.source.value === existingCompImportPath ||\n                          path.node.source.value === existingLoaderImportPath\n                        ) {\n                          path.remove()\n                        }\n                      },\n                    })\n                  }\n                },\n              },\n            },\n          },\n          {\n            root: process.cwd(),\n            minify: process.env.NODE_ENV === 'production',\n          },\n        ],\n      ].filter(Boolean),\n    }),\n  })\n}\n\nfunction getImportSpecifierAndPathFromLocalName(\n  programPath: babel.NodePath<t.Program>,\n  name: string,\n): {\n  specifier:\n    | t.ImportSpecifier\n    | t.ImportDefaultSpecifier\n    | t.ImportNamespaceSpecifier\n    | null\n  path: string | null\n} {\n  let specifier:\n    | t.ImportSpecifier\n    | t.ImportDefaultSpecifier\n    | t.ImportNamespaceSpecifier\n    | null = null\n  let path: string | null = null\n\n  programPath.traverse({\n    ImportDeclaration(importPath) {\n      const found = importPath.node.specifiers.find(\n        (targetSpecifier) => targetSpecifier.local.name === name,\n      )\n      if (found) {\n        specifier = found\n        path = importPath.node.source.value\n      }\n    },\n  })\n\n  return { specifier, path }\n}\n\n// Reusable function to get literal value or resolve variable to literal\nfunction resolveIdentifier(path: any, node: any) {\n  if (t.isIdentifier(node)) {\n    const binding = path.scope.getBinding(node.name)\n    if (\n      binding\n      // && binding.kind === 'const'\n    ) {\n      const declarator = binding.path.node\n      if (t.isObjectExpression(declarator.init)) {\n        return declarator.init\n      } else if (t.isFunctionDeclaration(declarator.init)) {\n        return declarator.init\n      }\n    }\n    return undefined\n  }\n\n  return node\n}\n\nfunction removeIdentifierLiteral(path: any, node: any) {\n  if (t.isIdentifier(node)) {\n    const binding = path.scope.getBinding(node.name)\n    if (binding) {\n      binding.path.remove()\n    }\n  }\n}\n\nconst splitNodeTypes = ['component', 'loader'] as const\ntype SplitNodeType = (typeof splitNodeTypes)[number]\n\nexport async function splitFile(opts: {\n  code: string\n  compileAst: CompileAstFn\n  filename: string\n}) {\n  return await opts.compileAst({\n    code: opts.code,\n    filename: opts.filename,\n    getBabelConfig: () => ({\n      plugins: [\n        [\n          {\n            visitor: {\n              Program: {\n                enter(programPath: babel.NodePath<t.Program>, state: State) {\n                  const splitNodesByType: Record<\n                    SplitNodeType,\n                    t.Node | undefined\n                  > = {\n                    component: undefined,\n                    loader: undefined,\n                  }\n\n                  // Find the node\n                  programPath.traverse(\n                    {\n                      CallExpression: (path) => {\n                        if (!t.isIdentifier(path.node.callee)) {\n                          return\n                        }\n\n                        if (\n                          !(\n                            path.node.callee.name === 'createRoute' ||\n                            path.node.callee.name === 'createFileRoute'\n                          )\n                        ) {\n                          return\n                        }\n\n                        if (t.isCallExpression(path.parentPath.node)) {\n                          const options = resolveIdentifier(\n                            path,\n                            path.parentPath.node.arguments[0],\n                          )\n\n                          if (t.isObjectExpression(options)) {\n                            options.properties.forEach((prop) => {\n                              if (t.isObjectProperty(prop)) {\n                                splitNodeTypes.forEach((type) => {\n                                  if (t.isIdentifier(prop.key)) {\n                                    if (prop.key.name === type) {\n                                      splitNodesByType[type] = prop.value\n                                    }\n                                  }\n                                })\n                              }\n                            })\n\n                            // Remove all of the options\n                            options.properties = []\n                          }\n                        }\n                      },\n                    },\n                    state,\n                  )\n\n                  splitNodeTypes.forEach((splitType) => {\n                    let splitNode = splitNodesByType[splitType]\n\n                    if (!splitNode) {\n                      return\n                    }\n\n                    while (t.isIdentifier(splitNode)) {\n                      const binding = programPath.scope.getBinding(\n                        splitNode.name,\n                      )\n                      splitNode = binding?.path.node\n                    }\n\n                    // Add the node to the program\n                    if (splitNode) {\n                      if (t.isFunctionDeclaration(splitNode)) {\n                        programPath.pushContainer(\n                          'body',\n                          t.variableDeclaration('const', [\n                            t.variableDeclarator(\n                              t.identifier(splitType),\n                              t.functionExpression(\n                                splitNode.id || null, // Anonymize the function expression\n                                splitNode.params,\n                                splitNode.body,\n                                splitNode.generator,\n                                splitNode.async,\n                              ),\n                            ),\n                          ]),\n                        )\n                      } else if (\n                        t.isFunctionExpression(splitNode) ||\n                        t.isArrowFunctionExpression(splitNode)\n                      ) {\n                        programPath.pushContainer(\n                          'body',\n                          t.variableDeclaration('const', [\n                            t.variableDeclarator(\n                              t.identifier(splitType),\n                              splitNode as any,\n                            ),\n                          ]),\n                        )\n                      } else if (\n                        t.isImportSpecifier(splitNode) ||\n                        t.isImportDefaultSpecifier(splitNode)\n                      ) {\n                        programPath.pushContainer(\n                          'body',\n                          t.variableDeclaration('const', [\n                            t.variableDeclarator(\n                              t.identifier(splitType),\n                              splitNode.local,\n                            ),\n                          ]),\n                        )\n                      } else if (t.isCallExpression(splitNode)) {\n                        const outputSplitNodeCode = generate(splitNode).code\n                        const splitNodeAst = babel.parse(outputSplitNodeCode)\n\n                        if (!splitNodeAst) {\n                          throw new Error(\n                            `Failed to parse the generated code for \"${splitType}\" in the node type \"${splitNode.type}\"`,\n                          )\n                        }\n\n                        const statement = splitNodeAst.program.body[0]\n\n                        if (!statement) {\n                          throw new Error(\n                            `Failed to parse the generated code for \"${splitType}\" in the node type \"${splitNode.type}\" as no statement was found in the program body`,\n                          )\n                        }\n\n                        if (t.isExpressionStatement(statement)) {\n                          const expression = statement.expression\n                          programPath.pushContainer(\n                            'body',\n                            t.variableDeclaration('const', [\n                              t.variableDeclarator(\n                                t.identifier(splitType),\n                                expression,\n                              ),\n                            ]),\n                          )\n                        } else {\n                          throw new Error(\n                            `Unexpected expression type encounter for \"${splitType}\" in the node type \"${splitNode.type}\"`,\n                          )\n                        }\n                      } else {\n                        console.info('Unexpected splitNode type:', splitNode)\n                        throw new Error(\n                          `Unexpected splitNode type ☝️: ${splitNode.type}`,\n                        )\n                      }\n                    }\n\n                    // If the splitNode exists at the top of the program\n                    // then we need to remove that copy\n                    programPath.node.body = programPath.node.body.filter(\n                      (node) => {\n                        return node !== splitNode\n                      },\n                    )\n\n                    // Export the node\n                    programPath.pushContainer('body', [\n                      t.exportNamedDeclaration(null, [\n                        t.exportSpecifier(\n                          t.identifier(splitType),\n                          t.identifier(splitType),\n                        ),\n                      ]),\n                    ])\n                  })\n\n                  // convert exports to imports from the original file\n                  programPath.traverse({\n                    ExportNamedDeclaration(path) {\n                      // e.g. export const x = 1 or export { x }\n                      // becomes\n                      // import { x } from '${opts.id}'\n\n                      if (path.node.declaration) {\n                        if (t.isVariableDeclaration(path.node.declaration)) {\n                          path.replaceWith(\n                            t.importDeclaration(\n                              path.node.declaration.declarations.map((decl) =>\n                                t.importSpecifier(\n                                  t.identifier((decl.id as any).name),\n                                  t.identifier((decl.id as any).name),\n                                ),\n                              ),\n                              t.stringLiteral(\n                                opts.filename.split(\n                                  `?${splitPrefix}`,\n                                )[0] as string,\n                              ),\n                            ),\n                          )\n                        }\n                      }\n                    },\n                  })\n\n                  eliminateUnreferencedIdentifiers(programPath)\n                },\n              },\n            },\n          },\n          {\n            root: process.cwd(),\n            minify: process.env.NODE_ENV === 'production',\n          },\n        ],\n      ].filter(Boolean),\n    }),\n  })\n}\n"],"names":["babel"],"mappings":"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"}